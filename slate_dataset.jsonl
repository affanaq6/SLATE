{"messages":[{"role":"system","content":"Explain and draw what a circle is?"},{"role":"model","content":"from manim import *\n\nclass DrawCircle(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        # Set color and line width\n        circle.set_fill(PINK, opacity=0.5)\n        circle.set_stroke(color=WHITE, width=4)\n\n        # Show creation of the circle\n        self.play(Create(circle))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a square?"},{"role":"model","content":"from manim import *\n\nclass DrawSquare(Scene):\n    def construct(self):\n        # Create a square\n        square = Square()\n        # Set color and line width\n        square.set_fill(BLUE, opacity=0.5)\n        square.set_stroke(color=WHITE, width=4)\n\n        # Show creation of the square\n        self.play(Create(square))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw an equilateral triangle?"},{"role":"model","content":"from manim import *\n\nclass DrawTriangle(Scene):\n    def construct(self):\n        # Create an equilateral triangle\n        triangle = Polygon(np.array([0, 1, 0]), np.array([-1, -1, 0]), np.array([1, -1, 0]))\n        # Set color and line width\n        triangle.set_fill(YELLOW, opacity=0.5)\n        triangle.set_stroke(color=WHITE, width=4)\n\n        # Show creation of the triangle\n        self.play(Create(triangle))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw combining shapes like a circle, square, and triangle?"},{"role":"model","content":"from manim import *\n\nclass CombineShapes(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        circle.set_fill(RED, opacity=0.5)\n        circle.set_stroke(color=WHITE, width=4)\n\n        # Create a square\n        square = Square()\n        square.set_fill(BLUE, opacity=0.5)\n        square.set_stroke(color=WHITE, width=4)\n\n        # Create an equilateral triangle\n        triangle = Polygon(np.array([0, 1, 0]), np.array([-1, -1, 0]), np.array([1, -1, 0]))\n        triangle.set_fill(GREEN, opacity=0.5)\n        triangle.set_stroke(color=WHITE, width=4)\n\n        # Arrange the shapes in a row\n        shapes = VGroup(circle, square, triangle).arrange(RIGHT, buff=1)\n\n        # Show creation of the shapes\n        self.play(Create(shapes))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw transforming a square into a circle?"},{"role":"model","content":"from manim import *\n\nclass TransformShape(Scene):\n    def construct(self):\n        # Create a square and a circle\n        square = Square()\n        circle = Circle()\n\n        # Position the square\n        square.shift(LEFT)\n\n        # Position the circle\n        circle.shift(RIGHT)\n\n        # Show square and transform it into circle\n        self.play(Create(square), Transform(square, circle))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw rotating a pentagon?"},{"role":"model","content":"from manim import *\n\nclass RotateShape(Scene):\n    def construct(self):\n        # Create a pentagon\n        pentagon = RegularPolygon(5)\n\n        # Set color\n        pentagon.set_fill(PURPLE, opacity=0.5)\n\n        # Rotate the pentagon\n        self.play(Rotate(pentagon, angle=2*PI))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw plotting the linear function y=2x+1?"},{"role":"model","content":"from manim import *\n\nclass PlotLinearFunction(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 5, 1],\n            axis_config={'color': BLUE}\n        )\n\n        # Create a line based on the equation y = 2x + 1\n        line = axes.plot(lambda x: 2*x + 1, color=GREEN)\n\n        # Label for the line\n        line_label = axes.get_graph_label(line, label='y=2x+1')\n\n        # Draw the line with an animation\n        self.play(Create(axes), Create(line), Write(line_label))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw plotting the quadratic function y=x^2?"},{"role":"model","content":"from manim import *\n\nclass PlotQuadraticFunction(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 10, 1],\n            axis_config={'color': BLUE}\n        )\n\n        # Create a quadratic function graph y = x^2\n        graph = axes.plot(lambda x: x**2, color=RED)\n\n        # Label for the graph\n        graph_label = axes.get_graph_label(graph, label='y=x^2')\n\n        # Create the axes and graph with an animated drawing\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw graphing multiple functions, specifically y = x and y = x^2?"},{"role":"model","content":"from manim import *\n\nclass GraphMultipleFunctions(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 9, 1],\n            axis_config={'color': BLUE}\n        )\n\n        # Function y = x\n        linear_function = axes.plot(lambda x: x, color=GREEN)\n        linear_label = MathTex('y = x').next_to(linear_function, UP+LEFT)\n\n        # Function y = x^2\n        quadratic_function = axes.plot(lambda x: x**2, color=RED)\n        quadratic_label = MathTex('y = x^2').next_to(quadratic_function, UP+RIGHT)\n\n        # Add all elements to the scene\n        graph = VGroup(axes, linear_function, linear_label, quadratic_function, quadratic_label)\n        self.play(Create(graph))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a parametric spiral?"},{"role":"model","content":"from manim import *\n\nclass ParametricSpiral(Scene):\n    def construct(self):\n        # Define a parametric curve for a spiral\n        def spiral(t):\n            return np.array([\n                t * np.cos(t),\n                t * np.sin(t),\n                0\n            ])\n\n        # Create a curve based on the spiral function\n        spiral_curve = ParametricFunction(\n            spiral, t_range = np.array([0, 10, 0.1]),\n            color = BLUE\n        )\n\n        # Add the curve to the scene and animate\n        self.play(Create(spiral_curve))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a Sierpinski triangle?"},{"role":"model","content":"from manim import *\n\nclass SierpinskiTriangle(Scene):\n    def construct(self):\n        # Recursive function to create Sierpinski triangle\n        def sierpinski(order, scale):\n            if order == 0:\n                return Triangle().scale(scale)\n            else:\n                triangle = sierpinski(order - 1, scale / 2)\n                return VGroup(\n                    triangle.copy().shift(LEFT*scale),\n                    triangle.copy().shift(RIGHT*scale),\n                    triangle.copy().shift(UP*scale)\n                )\n\n        # Create Sierpinski triangle of order 3\n        sierpinski_triangle = sierpinski(3, 2)\n\n        # Add the fractal to the scene and animate\n        self.play(Create(sierpinski_triangle))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a hexagon tessellation?"},{"role":"model","content":"from manim import *\n\nclass HexagonTessellation(Scene):\n    def construct(self):\n        # Create a hexagon\n        def hexagon():\n            return RegularPolygon(6, radius=1, stroke_color=BLUE, fill_color=ORANGE, fill_opacity=0.6)\n\n        # Arrange hexagons into a tessellation pattern\n        tessellation = VGroup(*[\n            hexagon().shift(i * np.sqrt(3) * RIGHT + j * np.sqrt(3) * UP * 0.5)\n            for i in range(-5, 5) for j in range(-5, 5)\n            if (i+j)%2 == 0\n        ])\n\n        # Add the tessellation to the scene and animate\n        self.play(Create(tessellation))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw the multiplication of complex numbers 1+2i and 2+1i?"},{"role":"model","content":"from manim import *\n\nclass ComplexNumberMultiplication(Scene):\n    def construct(self):\n        # Setup complex plane\n        plane = ComplexPlane().add_coordinates()\n        # Multiplication of two complex numbers\n        num1 = complex(1, 2)  # represented by 1 + 2i\n        num2 = complex(2, 1)  # represented by 2 + 1i\n        result = num1 * num2  # Result of the multiplication\n\n        # Plot points for complex numbers and the result\n        dot1 = Dot(plane.n2p(num1), color=YELLOW)\n        dot2 = Dot(plane.n2p(num2), color=RED)\n        result_dot = Dot(plane.n2p(result), color=GREEN)\n        dots = VGroup(dot1, dot2, result_dot)\n\n        # Labels for the points\n        dot1_label = MathTex(\"1+2i\").next_to(dot1, UP)\n        dot2_label = MathTex(\"2+1i\").next_to(dot2, UP)\n        result_label = MathTex(\"5i\").next_to(result_dot, UP)\n        labels = VGroup(dot1_label, dot2_label, result_label)\n\n        # Create and animate everything together\n        self.play(Create(plane), FadeIn(dots, labels, shift=UP), run_time=2)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw the Pythagorean Theorem?"},{"role":"model","content":"from manim import *\n\nclass PythagorasTheorem(Scene):\n    def construct(self):\n        # Define the points of the right-angled triangle\n        pointA = ORIGIN\n        pointB = 4 * RIGHT\n        pointC = 4 * RIGHT + 3 * UP\n\n        # Create the triangle\n        triangle = Polygon(pointA, pointB, pointC, color=WHITE)\n        triangle.set_fill(BLUE, opacity=0.5)\n\n        # Labels for the sides of the triangle\n        a_label = MathTex(\"c\", color=RED).next_to(triangle, LEFT, buff=0.1)\n        b_label = MathTex(\"b\", color=GREEN).next_to(triangle, DOWN, buff=0.1)\n        c_label = MathTex(\"a\", color=BLUE).next_to(triangle, RIGHT, buff=0.1)\n\n        # Heading for context\n        heading = Text(\"Pythagorean Theorem\", font_size=36).to_edge(UP)\n\n        # The theorem formula\n        theorem_formula = MathTex(\"c^2 = a^2 + b^2\", color=PURPLE).scale(1.5).next_to(heading, DOWN)\n\n        # Grouping all elements for a single animation command\n        all_elements = VGroup(triangle, a_label, b_label, c_label, heading, theorem_formula)\n\n        # Animate all elements together using DrawBorderThenFill for a coherent drawing effect\n        self.play(DrawBorderThenFill(all_elements), run_time=3)\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw visualizing the derivative of f(x) = x^2?"},{"role":"model","content":"from manim import *\n\nclass VisualizeDerivative(Scene):\n    def construct(self):\n        # Create axes and plots for the function and its derivative\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-5, 5, 1], axis_config={'color': BLUE})\n        func = axes.plot(lambda x: x**2, color=RED)\n        derivative = axes.plot(lambda x: 2*x, color=GREEN)\n        graphs = VGroup(axes, func, derivative)\n\n        # Labels for the functions\n        func_label = MathTex('f(x) = x^2').next_to(func, UP)\n        derivative_label = MathTex(\"f'(x) = 2x\").next_to(derivative, UP+RIGHT)\n        labels = VGroup(func_label, derivative_label)\n\n        # Create and animate everything together\n        self.play(Create(graphs), FadeIn(labels, shift=UP), run_time=2)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw the orbital mechanics of a planet around the sun?"},{"role":"model","content":"from manim import *\n\nclass OrbitalMechanics(Scene):\n    def construct(self):\n        # Define the colors and sizes for higher visibility\n        sun_color = YELLOW\n        planet_color = BLUE\n\n        # Sun setup\n        sun = Circle(radius=1, color=sun_color)  # Larger radius for the sun\n        sun.set_fill(sun_color, opacity=1)\n        sun.move_to(ORIGIN)\n\n        # Planet setup with explicit visibility enhancements\n        planet = Dot(radius=0.3, color=planet_color)  # Increased the radius of the planet\n        planet.set_fill(planet_color, opacity=1)\n        planet.move_to(5 * RIGHT)  # Increase the distance to make the orbit larger\n\n        # Orbit path (ellipse to represent the orbital path)\n        orbit_path = Ellipse(width=10, height=4, color=WHITE)  # Larger and wider orbit path\n\n        # Animation for the planet orbiting the sun\n        orbit_animation = Rotating(planet, about_point=ORIGIN, radians=2*PI, run_time=3, rate_func=smooth)\n\n        # Drawing the sun, planet, and orbit path with a clear distinction\n        self.play(\n            DrawBorderThenFill(sun),\n            Create(orbit_path),\n            GrowFromCenter(planet),\n            orbit_animation\n        )\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw the wave interference from two sources?"},{"role":"model","content":"from manim import *\n\nclass WaveInterference(Scene):\n    def construct(self):\n        # Wave sources\n        source_a = Dot(LEFT * 2)\n        source_b = Dot(RIGHT * 2)\n        waves_a = Circle(radius=2, color=BLUE).move_to(source_a.get_center())\n        waves_b = Circle(radius=2, color=RED).move_to(source_b.get_center())\n\n        # Interference pattern setup\n        interference_pattern = VGroup(waves_a, waves_b)\n\n        # Group all elements and animate\n        self.play(DrawBorderThenFill(source_a), DrawBorderThenFill(source_b), Create(interference_pattern), run_time=4)\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a bar chart for given categories?"},{"role":"model","content":"from manim import *\n\nclass BarChartExample(Scene):\n    def construct(self):\n        # Data for the bar chart\n        data = [2, 5, 3, 6]  # Sample data values\n        categories = ['A', 'B', 'C', 'D']  # Categories for the data\n\n        # Create a bar chart\n        bar_chart = BarChart(\n            values=data,\n            bar_names=categories,\n            bar_colors=[BLUE, YELLOW, GREEN, RED],\n            y_range=[0, 10, 1],  # Setting the range for the y-axis\n            y_length=6,  # The vertical length of the bars\n            x_length=6,  # The horizontal spacing of the bars\n        )\n\n        # Title for the bar chart\n        title = Title('Bar Chart Example')\n\n        # Animate the creation of the bar chart\n        self.play(\n            Write(title),\n            Create(bar_chart),\n            run_time=4\n        )\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a pie chart for given percentages?"},{"role":"model","content":"from manim import *\n\nclass PieChartExample(Scene):\n    def construct(self):\n        # Data for the pie chart\n        data = [30, 15, 20, 35]  # Percentages of each sector\n        colors = [TEAL, ORANGE, PURPLE_A, GOLD]  # Colors for each sector\n\n        # Total of all segments\n        total = sum(data)\n        current_angle = 0  # Start angle for the first segment\n        radius = 2  # Radius of the pie chart\n\n        # Create a pie chart from the data\n        pie_chart = VGroup()  # Initialize a group to store pie slices\n        labels = VGroup()  # Group for labels\n\n        for i, value in enumerate(data):\n            # Calculate the angle covered by the segment\n            angle = value / total * 360 * DEGREES\n\n            # Create a sector (pie slice)\n            sector = Sector(\n                start_angle=current_angle,\n                angle=angle,\n                color=colors[i],\n                fill_opacity=0.8,\n                outer_radius=radius\n            )\n\n            # Calculate label position\n            label_position = sector.get_center() + np.array([\n                radius * 0.75 * np.cos(current_angle + angle / 2),\n                radius * 0.75 * np.sin(current_angle + angle / 2),\n                0\n            ])\n\n            # Create label for the sector\n            label = MathTex(f\"{value}%\")\n            label.move_to(label_position)\n\n            # Add sector and label to their respective groups\n            pie_chart.add(sector)\n            labels.add(label)\n\n            # Update the start angle for the next sector\n            current_angle += angle\n\n        # Center the pie chart\n        pie_chart.move_to(ORIGIN)\n        labels.move_to(ORIGIN)\n\n        # Title for the pie chart\n        title = Title(\"Pie Chart Example\")\n\n        # Animate everything\n        self.play(\n            FadeIn(title),\n            Create(pie_chart),\n            FadeIn(labels),\n            run_time=4\n        )\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a historical timeline from 1900 to 2000 highlighting major events?"},{"role":"model","content":"from manim import *\n\nclass HistoricalTimeline(Scene):\n    def construct(self):\n        # Timeline setup\n        timeline = Line(LEFT * 5, RIGHT * 5, color=WHITE)\n        start_label = Text(\"1900\", font_size=24).next_to(timeline.get_start(), DOWN)\n        end_label = Text(\"2000\", font_size=24).next_to(timeline.get_end(), DOWN)\n\n        # Events\n        events = [\n            (\"WWI\", -4),\n            (\"Great Depression\", -2),\n            (\"WWII\", 0),\n            (\"Moon Landing\", 2),\n            (\"Fall of Berlin Wall\", 4),\n        ]\n\n        # Create event markers and labels\n        dots = VGroup()\n        labels = VGroup()\n        for event, pos in events:\n            dot = Dot().move_to(timeline.point_from_proportion((pos + 5) / 10))\n            label = Text(event, font_size=18).next_to(dot, UP)\n            dots.add(dot)\n            labels.add(label)\n\n        # Animate\n        self.play(Create(timeline), Write(start_label), Write(end_label))\n        self.wait(1)\n        for dot, label in zip(dots, labels):\n            self.play(GrowFromCenter(dot), Write(label))\n            self.wait(0.5)\n        \n        # Final wait\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a pentagon?"},{"role":"model","content":"from manim import *\n\nclass DrawPentagon(Scene):\n    def construct(self):\n        # Create a regular pentagon\n        pentagon = RegularPolygon(5)\n        # Set color and line width\n        pentagon.set_fill(ORANGE, opacity=0.5)\n        pentagon.set_stroke(color=WHITE, width=4)\n\n        # Animate the creation of the pentagon\n        self.play(Create(pentagon))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw the graph of the sine function?"},{"role":"model","content":"from manim import *\n\nclass PlotSineWave(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[-2, 2, 1],\n            axis_config={'color': BLUE}\n        )\n\n        # Create the sine wave graph\n        sine_wave = axes.plot(lambda x: np.sin(x), color=GREEN)\n\n        # Label for the sine wave\n        label = axes.get_graph_label(sine_wave, label='y = \\sin(x)')\n\n        # Draw axes and sine wave\n        self.play(Create(axes), Create(sine_wave), Write(label))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a 3D helix?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass Plot3DHelix(ThreeDScene):\n    def construct(self):\n        # Set up axes\n        axes = ThreeDAxes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            z_range=[-2, 2, 1]\n        )\n\n        # Define the parametric function for a helix\n        helix = ParametricFunction(\n            lambda t: np.array([\n                np.cos(t),\n                np.sin(t),\n                t / 2  # Control the vertical displacement\n            ]),\n            t_range=np.array([0, 10*PI, 0.1]),  # Several twists\n            color=RED\n        )\n\n        # Draw everything\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes)\n        self.play(Create(helix))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and draw a 3D surface plot for the function z=sin(x) * cos(y)?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass Surface3DPlot(ThreeDScene):\n    def construct(self):\n        # Create axes\n        axes = ThreeDAxes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            z_range=[-1, 1, 0.5]\n        )\n\n        # Define the surface function z = sin(x) * cos(y)\n        surface = Surface(\n            lambda u, v: axes.c2p(u, v, np.sin(u) * np.cos(v)),\n            u_range=[-PI, PI],\n            v_range=[-PI, PI],\n            color=BLUE\n        )\n\n        # Set up the scene\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n        self.add(axes)\n        self.play(Create(surface))\n        self.begin_ambient_camera_rotation(rate=0.2)  # Optional: Rotate the camera\n        self.wait(4)"}]}
{"messages":[{"role":"system","content":"Can you explain and show a 3D rotation of a cube and a sphere?"},{"role":"model","content":"from manim import *\n\nclass CubeSphereRotation(ThreeDScene):\n    def construct(self):\n        # Create a cube and a sphere\n        cube = Cube()\n        sphere = Sphere()\n\n        # Position the sphere to the right of the cube\n        sphere.shift(RIGHT * 3)\n\n        # Set initial colors\n        cube.set_color(BLUE)\n        sphere.set_color(RED)\n\n        # Prepare the scene\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n        self.add(cube, sphere)\n        self.wait(1)\n\n        # Animate rotation around the y-axis\n        self.play(Rotate(cube, angle=PI/2, axis=UP), Rotate(sphere, angle=PI/2, axis=UP), run_time=2)\n        self.wait(1)\n\n        # Further rotation around the x-axis\n        self.play(Rotate(cube, angle=PI/2, axis=RIGHT), Rotate(sphere, angle=PI/2, axis=RIGHT), run_time=2)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and show a 3D vector field?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass VectorField3D(ThreeDScene):\n    def construct(self):\n        # Define a vector field\n        field = ArrowVectorField(\n            lambda pos: np.cross(pos, OUT + SMALL_BUFF * UP),\n            x_range=[-2, 2, 1],\n            y_range=[-2, 2, 1],\n            z_range=[-2, 2, 1]\n        )\n\n        # Set up the camera\n        self.set_camera_orientation(phi=45 * DEGREES, theta=135 * DEGREES)\n        self.add(field)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(4)"}]}
{"messages":[{"role":"system","content":"Can you explain and show a surface of revolution generated from a parabola?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass SurfaceOfRevolution(ThreeDScene):\n    def construct(self):\n        # Define a parabola\n        def curve(t):\n            return np.array([t, t**2, 0])\n\n        # Generate the surface of revolution\n        surface = Surface(\n            lambda u, v: curve(u) @ np.array([\n                [np.cos(v), 0, np.sin(v)],\n                [0, 1, 0],\n                [-np.sin(v), 0, np.cos(v)]\n            ]),\n            u_range=[-2, 2],  # range for the parabola\n            v_range=[0, 2 * PI],  # full circle revolution\n            checkerboard_colors=[BLUE_D, BLUE_E],\n            resolution=(20, 20)\n        )\n\n        # Setup the scene\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        self.add(surface)\n        self.wait(1)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(5)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of colliding pendulums?"},{"role":"model","content":"from manim import *\n\nclass CollidingPendulums(Scene):\n    def construct(self):\n        # Create two pendulums\n        pendulum1 = Line(UP * 2, DOWN * 2).set_stroke(width=3).move_to(LEFT * 2)\n        pendulum2 = Line(UP * 2, DOWN * 2).set_stroke(width=3).move_to(RIGHT * 2)\n        ball1 = Circle(radius=0.2, color=BLUE).next_to(pendulum1, DOWN)\n        ball2 = Circle(radius=0.2, color=RED).next_to(pendulum2, DOWN)\n        \n        # Grouping them\n        group1 = VGroup(pendulum1, ball1)\n        group2 = VGroup(pendulum2, ball2)\n\n        # Animation\n        self.play(FadeIn(group1), FadeIn(group2))\n        self.play(Rotate(group1, angle=PI/4, about_point=UP*2 + LEFT*2),\n                  Rotate(group2, angle=-PI/4, about_point=UP*2 + RIGHT*2),\n                  run_time=2, rate_func=there_and_back, repeat=3)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of an expanding and collapsing circle grid?"},{"role":"model","content":"from manim import *\n\nclass ExpandingCollapsingCircleGrid(Scene):\n    def construct(self):\n        # Create a grid of circles\n        grid = VGroup(*[Circle(radius=0.2, color=WHITE).shift(x * RIGHT + y * UP)\n                       for x in range(-4, 5, 2)\n                       for y in range(-3, 4, 2)])\n\n        # Animation\n        self.play(LaggedStart(*[GrowFromCenter(circle) for circle in grid], lag_ratio=0.1),\n                  run_time=2)\n        self.wait(1)\n        self.play(LaggedStart(*[ShrinkToCenter(circle) for circle in grid], lag_ratio=0.1),\n                  run_time=2)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of an evolving Lissajous curve?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass LissajousAnimation(Scene):\n    def construct(self):\n        # Lissajous curve parameters that evolve over time\n        a = 3\n        b = 2\n        delta = PI / 2\n\n        # Create a Lissajous curve\n        lissajous_curve = ParametricFunction(\n            lambda t: np.array([\n                np.sin(a * t + delta),\n                np.sin(b * t),\n                0\n            ]),\n            t_range=[0, 2*PI],\n            color=RED\n        )\n\n        # Animating the evolution of the curve\n        self.play(Create(lissajous_curve), run_time=2)\n        self.wait(1)\n\n        # Change parameters over time\n        self.play(lissajous_curve.animate.set_function(\n            lambda t: np.array([\n                np.sin((a+1) * t + delta),\n                np.sin((b+1) * t),\n                0\n            ])\n        ), run_time=5)\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of bouncing balls in a box with gravity?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass BouncingBalls(Scene):\n    def construct(self):\n        box = Rectangle(height=6, width=6).set_color(WHITE)\n        balls = VGroup(*[Circle(radius=0.2, color=random_bright_color()).move_to(\n            np.array([np.random.uniform(-3, 3), np.random.uniform(-3, 3), 0]))\n            for _ in range(5)])\n        gravity = np.array([0, -0.1, 0])\n        velocities = [np.random.uniform(-1, 1, size=3) for _ in balls]\n\n        self.add(box, balls)\n        for _ in range(200):  # 200 frames of animation\n            self.wait(0.05)\n            for ball, vel in zip(balls, velocities):\n                new_point = ball.get_center() + vel\n                if not (-3 <= new_point[0] <= 3 and -3 <= new_point[1] <= 3):\n                    vel *= -1  # Reverse the velocity if it hits the walls\n                vel += gravity  # Apply gravity to velocity\n                ball.shift(vel)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of the Moon orbiting around the Earth?"},{"role":"model","content":"from manim import *\n\nclass EarthMoonOrbit(ThreeDScene):\n    def construct(self):\n        # Set up the scene with Earth and Moon\n        earth = Sphere(radius=1, color=BLUE, resolution=(32, 32))\n        moon = Sphere(radius=0.2, color=GRAY, resolution=(32, 32)).shift(RIGHT * 3)  # 3 units away from Earth\n\n        # Add Earth and Moon to the scene\n        self.add(earth, moon)\n\n        # Set up the camera\n        self.set_camera_orientation(phi=75 * DEGREES, theta=45 * DEGREES)\n        \n        # Animate the Moon orbiting around the Earth\n        self.play(Rotate(moon, about_point=ORIGIN, angle=2*PI, run_time=10, rate_func=linear))\n\n        # Keep the camera stationary and let the animation loop\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of a wormhole?"},{"role":"model","content":"from manim import *\n\nclass WormholeIllustration(ThreeDScene):\n    def construct(self):\n        # Define spheres representing entry and exit points\n        sphere1 = Sphere(radius=1, color=BLUE).shift(LEFT * 3)\n        sphere2 = Sphere(radius=1, color=RED).shift(RIGHT * 3)\n\n        # Define the \"throat\" of the wormhole as a cylinder\n        throat = Cylinder(radius=0.5, height=6, direction=RIGHT * 6).set_color(GREEN)\n\n        # Set up the scene\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n        self.add(sphere1, sphere2, throat)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(5)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of a planetary orbit system?"},{"role":"model","content":"from manim import *\n\nclass PlanetaryOrbitSystem(ThreeDScene):\n    def construct(self):\n        # Create the sun and planets\n        sun = Sphere(radius=1, color=YELLOW).move_to(ORIGIN)\n        planet = Sphere(radius=0.2, color=BLUE).move_to(RIGHT * 5)\n\n        # Define the orbit path\n        orbit = Circle(radius=5, color=WHITE).set_stroke(width=2)\n\n        # Set up the scene\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        self.add(sun, planet, orbit)\n        self.play(Rotate(planet, about_point=ORIGIN, angle=2*PI, run_time=10, rate_func=linear))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(10)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of the complex function f(z) = z^2 applied to the complex plane?"},{"role":"model","content":"from manim import *\n\nclass ComplexFunctionVisual(ThreeDScene):\n    def construct(self):\n        # Define the complex function: f(z) = z^2\n        def func(z):\n            return z**2\n\n        # Create a complex plane\n        plane = ComplexPlane().add_coordinates()\n        \n        # Map the complex function onto the plane\n        mapped_plane = plane.copy().apply_complex_function(func)\n\n        # Set up the scene\n        self.add(plane)\n        self.play(Transform(plane, mapped_plane))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"Can you explain and show an animation of constructing a hexagon within a circle?"},{"role":"model","content":"from manim import *\n\nclass HexagonConstruction(Scene):\n    def construct(self):\n        # Center point\n        center = Dot()\n        # Initial circle\n        circle = Circle(radius=2)\n        circle.move_to(center)\n\n        # Points for hexagon\n        points = [circle.point_at_angle(i * PI / 3) for i in range(6)]\n        hexagon = Polygon(*points, color=BLUE)\n\n        # Construction animation\n        self.play(Create(center))\n        self.play(Create(circle))\n        self.play(Create(hexagon))\n        self.wait(1)\n\n        # Label vertices\n        labels = VGroup(*[Text(f\"P{i+1}\").next_to(points[i], DOWN, buff=0.1) for i in range(6)])\n        self.play(*[Write(label) for label in labels])\n        self.wait(1)"}]}
